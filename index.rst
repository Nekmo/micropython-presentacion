
.. toctree::
   :glob:
   :hidden:

   *

.. _intro:

###########
Micropython
###########

.. revealjs-section::
    :data-background-color: #36760d
    :data-transition-speed: slow
    :data-transition: fade

**Programaci√≥n f√°cil y para todos de microcontroladores**

.. revealjs-notes::

  Hola a todos, muchas gracias por venir.



Sobre m√≠ **Nekmo**
==================

.. revealjs-section::
    :data-background-color: #090a0f
    :data-transition-speed: slow
    :data-transition: fade

+------------------------------------+
|                                    |
| .. image:: images/cara.svg         |
|   :width: 200px                    |
|                                    |
| *Programador Python*               |
|                                    |
+------------------------------------+

.. revealjs-notes::

   Soy Juan Jos√©, aunque muchos me conocen en redes como Nekmo, y puede que me conozc√°is por charlas anteriores para Python M√°laga


Otras charlas...
================

.. image:: images/talks1.jpg
   :width: 32%
   :align: center

.. image:: images/talks2.jpg
   :width: 32%
   :align: center

----------

.. image:: images/python-malaga-logo-white.png
   :width: 10%
   :align: center

.. image:: images/plytix-logo-white.svg
   :width: 35%
   :align: center

.. revealjs-section::
    :data-background-color: #090a0f

.. revealjs-notes::

   Como la √∫ltima que tuvimos en Plytix, la empresa para la que trabajo, y que pod√©is encontrar disponible online.
   Pero en esta ocasi√≥n, tendremos una charla un tanto diferente, aqu√≠ en OpenSouthCode...


Micropython
===========

.. image:: images/micropython-logo.svg
   :width: 35%
   :align: center

.. revealjs-section::
    :data-background-color: #090a0f

.. revealjs-notes::

   Vamos a hablar de microcontroladores y Micropython, un √°mbito seguramente diferente para muchos. Por ello, me
   gustar√≠a saber cu√°ntos conoc√©is ya sobre este mundillo.



Microcontroladores
==================

.. revealjs-section::
    :data-background-color: #000000
    :data-background-image: _static/microcontrollers_background.png

.. revealjs-notes::

   No os preocup√©is por los que no conozc√°is sobre este el tema, ya que iremos desde el principio.



¬øQu√© son?
---------

.. revealjs-section::
    :data-background-color: #090a0f

.. revealjs-fragments::

    * **Ventajas**

      * ü§è Peque√±os
      * ü§ë Econ√≥micos
      * ü™´ Bajo consumo

    * **Desventajas**

      * üê¢ Poco potentes
      * üòì Programaci√≥n m√°s compleja

.. revealjs-notes::

   Como os podr√©is imaginar por el nombre, los microcontroladores son peque√±os ordenadores, como puede ser una Raspberry
   Pi, pero mucho m√°s peque√±os y con menos recursos. Entre sus ventajas tenemos [...] y entre sus desventajas [...].



Algunos **usos**
----------------

.. revealjs-section::
    :data-background-color: #090a0f

.. revealjs-fragments::

    * ‚òÅÔ∏è Dom√≥tica
    * ü§ñ Rob√≥tica
    * üîå Electr√≥nica
    * üöß Prototipos
    * ...

.. revealjs-notes::

   Se utilizan en muchos √°mbitos, como la dom√≥tica, rob√≥tica, electr√≥nica, prototipos y muchos m√°s.



GIF robot
---------

.. revealjs-section::
    :data-background-color: #333333
    :data-background-video: _static/robot_fall.mp4
    :data-background-video-loop: true
    :data-background-size: cover

.. revealjs-notes::

   Gracias a ellos, podr√©is competir contra Boston Dynamics en rob√≥tica, y conseguir im√°genes graciosas como esta.


Micropython
===========

.. image:: images/micropython-logo.svg
   :width: 35%
   :align: center

.. revealjs-section::
    :data-background-color: #090a0f

.. revealjs-notes::

   Si record√°is, hemos dicho como uno de sus puntos d√©biles que son dif√≠ciles de programar. Y hasta hace no mucho era
   as√≠. Pero desde hace unos a√±os, tenemos algunas soluciones como Micropython que nos permiten programar estos
   microcontroladores de una forma m√°s sencilla. Micropython es una variante de Python 3 reducida y adaptada para
   algunos de estos microcontroladores.



Variantes
---------

.. revealjs-section::
    :data-background-color: #090a0f

.. revealjs-fragments::

    * **ESP8266/ESP32**

      * ü§ë Muy **econ√≥mico**
      * üòÑ M√∫ltiples **variantes**
      * üë• Gran **comunidad**

    * **Raspberry Pi Pico**

      * üí∏ **Econ√≥mico**
      * üî® Gran **soporte**
      * üìö Bien **documentado**

.. revealjs-notes::

   Entre los microcontroladores que soportan Micropython podemos destacar los ESP8266 y ESP32 [...] o la Raspberry Pi Pico [...], u otros m√°s caros como la PyBoard, la oficial de Miccropython.



ESP32
=====

.. revealjs-section::
    :data-background-color: #000000
    :data-background-image: _static/esp32_background.jpg

.. revealjs-notes::

   Pero en esta presentaci√≥n vamos a utilizar un ESP32, porque sencillamente...



Dinero
------

.. revealjs-section::
    :data-background-color: #333333
    :data-background-video: _static/empty_wallet.mkv
    :data-background-video-loop: true
    :data-background-size: cover

.. revealjs-notes::

   ... la pela es la pela. Y es que son los m√°s econ√≥micos.



Caracter√≠sticas
---------------

.. revealjs-section::
    :data-background-color: #090a0f

.. revealjs-fragments::

    * üí™ **Doble** n√∫cleo
    * üõú Conectividad **WiFi**
    * üì° Conectividad **Bluetooth**
    * üîå M√∫ltiples pines **GPIO**
    * üìü **ADC** / **DAC**

.. revealjs-notes::

   Pero no s√≥lo es barato. Tambi√©n tiene un mont√≥n de caracter√≠sticas interesantes como [...]. Y todo ello partiendo
   desde 3-4‚Ç¨.



**Primeros** pasos
------------------

.. revealjs-section::
    :data-background-color: #090a0f

.. revealjs-fragments::

    * ‚ö° **Flashear** siguiendo la web de `Micropython <https://micropython.org/>`_
    * üìù **IDE web** *(ViperIDE)* o local *(Thonny)*


.. revealjs-notes::

   Y empezar con Micropython es muy sencillo. S√≥lo ten√©is que descargar el binario del sitio web oficial, y flashearlo
   mediante la herramienta indicado. Tras ello, pod√©is usar un IDE web como Viper IDE, o un IDE local como Thonny.



Demos
=====

.. revealjs-section::
    :data-background-color: #333333
    :data-background-video: _static/resistor_fire.mp4
    :data-background-video-loop: true
    :data-background-size: cover

.. revealjs-notes::

   Y ya me voy callando, que seguro que lo que quer√©is ver son cosas en acci√≥n, y demos que luego no funcionar√°n.



Encender un **led**
===================

.. revealjs-section::
    :data-background-color: #333333
    :data-background-video: _static/leds.mp4
    :data-background-video-loop: true
    :data-background-size: cover

.. revealjs-notes::

   Vamos a empezar por lo m√°s sencillo de todo. Encender un led. El ejemplo m√°s t√≠pico de todos.



Identificar **los pines**
-------------------------

.. revealjs-section::
   :data-background-color: #DDDDDD

.. image:: images/datasheet.png
   :width: 60%

.. revealjs-notes::

   Aunque antes de empezar cualquier circuito, es imprescindible identificar los pines de nuestro controlador. Buscad
   vuestro modelo y encontrar√©is un datasheet como este. Los pines GPIO, que suelen empezar por G o algo similar, son
   los que nos interesan.


**Conectar** el led
-------------------

.. revealjs-section::
   :data-background-color: #DDDDDD

.. video:: _static/sheet1.mkv
   :autoplay:
   :loop:
   :muted:

.. revealjs-notes::

   Empezar con un led es tan sencillo como conectarlo en su polo positivo a un pin GPIO y el negativo a tierra.
   Opcionalmente podemos a√±adir una resistencia para proteger el led, aunque no es imprescindible.



C√≥digo **led**
--------------

.. revealjs-section::
    :data-background-color: #090a0f

.. micropython-demo::
   :video: _static/demo1.mp4

   from machine import Pin
   from time import sleep

   led = Pin(1, Pin.OUT)

   while True:
       led.on()
       sleep(0.5)
       led.off()
       sleep(0.5)

.. revealjs-notes::

   El c√≥digo fuente es tal que as√≠. En este ejemplo, haremos encender y apagarse el led en tiempos de medio segundo.
   Como pod√©is observar, el c√≥digo es muy similar al Python de siempre, donde utilizamos la librer√≠a de GPIO para
   definir qu√© pin, en este caso el GPIO 1, es el que queremos utilizar. Luego, lo inicializamos como salida. Tendremos
   as√≠ una salida digital, es decir, binaria, que puede ser 0 o 1.


Led **anal√≥gico**
-----------------

.. revealjs-section::
    :data-background-color: #090a0f

.. micropython-demo::
   :video: _static/demo2.mp4

   from machine import Pin, PWM
   from time import sleep

   led = PWM(Pin(1), freq=1000)

   while True:
       for i in range(0, 1024, 10):
           led.duty(i)
           sleep(0.01)
       for i in range(1023, -1, -10):
           led.duty(i)
           sleep(0.01)

.. revealjs-notes::

   El ejemplo anterior funcionaba de forma digital. Es decir, que el led s√≥lo pod√≠a encenderse y apagarse. Pero si
   utilizamos una salida anal√≥gica, indicada como PWM, podemos entregar m√°s valores, entre 0 y 1024, para as√≠ variar
   la intensidad del led.



GIF luces LED
-------------

.. revealjs-section::
    :data-background-color: #333333
    :data-background-video: _static/house_leds.mp4
    :data-background-video-loop: true
    :data-background-size: cover

.. revealjs-notes::

   Y ahora, ya sab√©is c√≥mo llenar vuestra casa de lucecitas LED.



Conectar **un bot√≥n**
=====================

.. revealjs-section::
   :data-background-color: #DDDDDD

.. video:: _static/sheet3.mkv
   :autoplay:
   :loop:
   :muted:

.. revealjs-notes::

   No s√≥lo podemos entregar valores de salida. Tambi√©n podemos leer valores de entrada, como es el caso de un bot√≥n.
   La conexi√≥n es igualmente sencilla, pero no utilizaremos una resistencia, ya que el propio microcontrolador tiene una
   resistencia pull-up interna. Si quer√©is m√°s detalles al respecto, me pod√©is preguntar al finalizar la charla. Y as√≠
   ya os dejo una pregunta para el final.



**C√≥digo** bot√≥n
----------------

.. revealjs-section::
    :data-background-color: #090a0f

.. micropython-demo::
   :video: _static/demo3.mp4

   from machine import Pin
   from time import sleep

   button = Pin(1, Pin.IN, Pin.PULL_UP)

   while True:
       state = not button.value()
       print(int(state))
       sleep(0.1)


.. revealjs-notes::

   Tenemos algo muy similar al led, pero en este caso el pin como entrada, y hemos configurado el pull-up interno.
   Gracias al pull-up, protegeremos el pin de cortocircuitos, pero debemos tener en cuenta que por ello tendremos valor
   1 cuando el bot√≥n no est√© presionado, y valor 0 cuando s√≠ lo est√©.



GIF recreativa
--------------

.. revealjs-section::
    :data-background-color: #333333
    :data-background-video: _static/arcades.mp4
    :data-background-video-loop: true
    :data-background-size: cover

.. revealjs-notes::

   Con esto, ya est√°is capacitados para crear vuestra propia recreativa con todos los botones que quer√°is.



Conectar un **LED RGB**
=======================

.. revealjs-section::
   :data-background-color: #DDDDDD

.. video:: _static/sheet4.mkv
   :autoplay:
   :loop:
   :muted:

.. revealjs-notes::

   Y para vuestra recreativa, no pueden faltar LEDs RGB a todo color. Como muchos sabr√©is, las siglas de RGB proceden de
   Red, Green y Blue, que son los colores primarios de la luz. Cada uno de estos colores corresponder√° a un pin GPIO,
   por lo que necesitaremos tres pines, y un cuarto pin para tierra.



**C√≥digo** LED RGB
------------------

.. revealjs-section::
    :data-background-color: #090a0f

.. micropython-demo::
   :video: _static/demo4.mp4

   from machine import Pin, PWM
   from time import sleep
   import urandom

   r = PWM(Pin(1), freq=1000)
   g = PWM(Pin(2), freq=1000)
   b = PWM(Pin(3), freq=1000)

   def set_color(red, green, blue):
       r.duty(red)
       g.duty(green)
       b.duty(blue)

   while True:
       red = urandom.getrandbits(10)
       green = urandom.getrandbits(10)
       blue = urandom.getrandbits(10)
       set_color(red, green, blue)
       sleep(1)


.. revealjs-notes::

   El c√≥digo es muy similar al que utilizamos antes con un led normal en modo anal√≥gico, pero en este caso tenemos 3
   pines, como si tuvi√©semos 3 leds diferentes, aunque en realidad est√°n encapsulados en uno solo. Este c√≥digo genera
   colores aleatorios, con valores 0 y 1024 para cada uno.



GIF cientos de cables
---------------------

.. revealjs-section::
    :data-background-color: #333333
    :data-background-video: _static/cables.mp4
    :data-background-video-loop: true
    :data-background-size: cover

.. revealjs-notes::

   Pero claro, si quisi√©semos tener varios leds RGB, cada uno con su color, necesitar√≠amos un mont√≥n de cables y ocupar
   todos los pines GPIO de nuestra placa, los cuales son muy valiosos. Para ello disponemos de protocolos de
   comunicaci√≥n, que nos permiten comunicarnos con varios dispositivos a la vez.



**Protocolos** de comunicaci√≥n
==============================

.. revealjs-section::
    :data-background-color: #090a0f

.. revealjs-fragments::

    * 1Ô∏è‚É£ **OneWire** (1 pin)
    * 2Ô∏è‚É£ **I2C** (2 pines)
    * 3Ô∏è‚É£ **SPI** (3/4+ pines)
    * üìü **UART** (2+ pines)

.. revealjs-notes::

   Disponemos de diferentes protocolos de comunicaci√≥n, que suelen variar en el n√∫mero de pines, en su velocidad,
   su uso, etc. Por ejemplo, oneWire s√≥lo llega a necesitar un pin, pero es muy lento. I2C s√≥lo necesita 2 pines, siendo
   muy popular. SPI parte de 3 a 4 pines, pudiendo requerir m√°s si tenemos varios dispositivos. UART, que algunos
   recordar√©is de los serial bus, parte de 2 pines... y as√≠ podr√≠amos continuar. Tambi√©n tenemos protocolos espec√≠ficos
   y dise√±ados para casos concretos, como el que veremos ahora. Recordad que con cada protocolo, necesitaremos utilizar
   adicionalmente una tierra, que no se cuenta como pin de comunicaci√≥n.



Conectar un **led WS2812**
==========================

.. revealjs-section::
   :data-background-color: #DDDDDD

.. video:: _static/sheet5.mkv
   :autoplay:
   :loop:
   :muted:

.. revealjs-notes::

   Vamos a empezar con el protocolo WS2812, que es el que utilizan los LEDs RGB de tipo NeoPixel. Este protocolo
   unidireccional s√≥lo necesita un pin de datos, pudiendo conectar varios LEDs a la vez, cada uno con su color. Tenemos
   como cables adicionales el de tierra y el de alimentaci√≥n, que en este caso es de 5V.



**C√≥digo** LED WS2812
---------------------

.. revealjs-section::
    :data-background-color: #090a0f

.. micropython-demo::
   :video: _static/demo5.mp4

   import apa106
   from machine import Pin
   from time import sleep

   NUM_LEDS = 3
   PIN_NUM = 1

   leds = apa106.APA106(Pin(PIN_NUM), NUM_LEDS)
   colors = [(255, 0, 0), (0, 255, 0), (0, 0, 255)]
   positions = list(range(NUM_LEDS))

   while True:
       for i in range(NUM_LEDS):
           leds[i] = colors[positions[i]]
       leds.write()
       positions = [(pos + 1) % NUM_LEDS for pos in positions]
       sleep(0.5)


.. revealjs-notes::

   En este c√≥digo utilizaremos el m√≥dulo apa106, incluido de serie en Micropython. Este m√≥dulo incluye ya el protocolo
   de comunicaci√≥n WS2812, por lo que lo √∫nico que tendremos que hacer es definir el n√∫mero de LEDs y el pin de datos.
   Rotaremos los colores RGB de cada entre cada uno de los LEDs.



**I2C**
=======

.. revealjs-section::
    :data-background-image: _static/i2c_background.png
    :data-background-size: cover

.. revealjs-notes::

   Aunque el protocolo WS2812 nos permite controlar m√∫ltiples LEDs individualmente con un solo cable, es un protocolo
   unidireccional dise√±ado en exclusiva para LEDs. En cambio, tenemos otros protocolos como I2C, que nos permiten
   comunicarnos con otros dispositivos, como pantallas, sensores, etc. Es un protocolo bidireccional que como dijimos
   antes, s√≥lo necesita 2 pines.



Conectar **sensor** y **pantalla I2C**
======================================

.. revealjs-section::
   :data-background-color: #DDDDDD

.. video:: _static/sheet6.mkv
   :autoplay:
   :loop:
   :muted:

.. revealjs-notes::

   Vamos a conectar tanto la pantalla como un sensor de temperatura a un mismo I2C, el cual utiliza 2 pines, SDA y SCL.
   Necesitaremos adem√°s una tierra y una alimentaci√≥n. Cada dispositivo I2C tiene una direcci√≥n √∫nica, la cual debemos
   conocer para comunicarnos con √©l. No obstante, podemos utilizar el esc√°ner I2C para conocer la direcci√≥n de nuestros
   dispositivos. En este caso, la pantalla es una OLED de 128x64 p√≠xeles, y el sensor un SHT41 para medir la temperatura
   y humedad.



**C√≥digo** sensor y pantalla I2C
--------------------------------

.. revealjs-section::
    :data-background-color: #090a0f

.. micropython-demo::
   :video: _static/demo6.mp4

   from machine import Pin, I2C
   from time import sleep
   import ssd1306
   import sht4x

   i2c = I2C(0, scl=Pin(1), sda=Pin(2))
   print(i2c.scan())
   oled = ssd1306.SSD1306_I2C(128, 64, i2c, 0x3C)
   sensor = sht4x.SHT4X(i2c, 0x44)

   while True:
       temperature, humidity = sensor.measurements
       oled.fill(0)
       oled.text("Temp: {:.1f} C".format(temperature), 0, 0)
       oled.text("Hum:  {:.1f} %".format(humidity), 0, 20)
       oled.show()
       sleep(2)

.. revealjs-notes::

   Para este c√≥digo, hemos tenido que instalar 2 m√≥dulos adicionales, para lo cual pod√©is usar upip, el gestor de
   paquetes de Micropython. Hemos instalado el m√≥dulo ssd1306 para la pantalla, y el m√≥dulo sht4x para el sensor.
   Tenemos como direcciones para los dispositivos la 0x3C para la pantalla y la 0x44 para el sensor.



**WiFi** y **bluetooth**
========================

.. revealjs-section::
    :data-background-image: _static/wireless_background.png
    :data-background-size: cover

.. revealjs-notes::

   Pero no s√≥lo disponemos de protocolos de comunicaci√≥n al√°mbrica. En controladores como el ESP32 disponemos de Wifi,
   Bluetooth, y algunos modelos Zigbee.



**C√≥digo** coche
----------------

.. revealjs-section::
    :data-background-color: #090a0f

.. revealjs-section::
    :data-background-color: #000303

.. micropython-demo::
    :video: _static/demo7.mp4

    import json
    import time
    from math import sqrt
    import network
    import ubinascii
    import uhashlib
    import ustruct
    import web
    from hardware import I2C
    from hardware import Pin
    from web import WebSocket
    import uasyncio as asyncio

    i2c0 = I2C(0, scl=Pin(26), sda=Pin(0), freq=400000)
    i2c0.writeto_mem(0x38, 0x00, bytearray([0, 0, 0, 0]))

    ap = network.WLAN(network.AP_IF)
    ap.active(True)
    ap.config(essid='roverc.pro', password='roverc.pro', authmode=network.AUTH_WPA_WPA2_PSK)


    while not ap.active():
        time.sleep(1)


    ip = ap.ifconfig()[0]
    print('IP:', ip)


    app = web.App(host='0.0.0.0', port=80)


    def normalize_value(value: int | float) -> bytes:
        value = int(value)
        if value >= 128:
            value = 127  # The maximum value in positive is 127
        if value < 0:
            value = (256 + value)
        return value.to_bytes(1, "big")


    def coords_to_mecano_wheels(x: int, y: int, maximum: int = 127):
        r1 = x + y
        r2 = -x + y
        r3 = -x + y
        r4 = x + y
        # r3 = x + y
        # r4 = -x + y
        values = [r1, r2, r3, r4]
        max_val = max(abs(v) for v in values)
        if max_val > maximum:
            factor = maximum / max_val
            values = [v * factor for v in values]
        return [normalize_value(v) for v in values]


    async def serve_static(w, filename, mimetype):
        # write http headers
        w.write('HTTP/1.0 200 OK\r\n')
        w.write(f'Content-Type: {mimetype}; charset=utf-8\r\n')
        w.write('\r\n')
        # write page body
        with open(filename, 'r') as f:
            w.write(f.read())
        # drain stream buffer
        await w.drain()


    # root route handler
    @app.route('/')
    async def handler(r, w):
        return await serve_static(w, "index.html", "text/html")


    # root route handler
    @app.route('/joy.min.js')
    async def serve_script(r, w):
        return await serve_static(w, "joy.min.js", "application/javascript")


    # /ws WebSocket route handler
    @app.route('/ws')
    async def ws_handler(r, w):
        # upgrade connection to WebSocket
        ws = await WebSocket.upgrade(r, w)
        latest = None
        while True:
            evt = await ws.recv()
            if evt is None or evt['type'] == 'close':
                # handle closed stream/close event
                break
            elif evt['type'] == 'text':
                # print received messages and echo them
                print('Received:', evt['data'])
                data = json.loads(evt['data'])
                if "x" in data and "y" in data:
                    x, y = data['x'], data['y']
                    if (x, y) == latest:
                        continue
                    try:
                        wheel1, wheel2, wheel3, wheel4 = coords_to_mecano_wheels(x, y)
                    except OverflowError:
                        continue
                    print("Wheels:", *(w[0] for w in (wheel1, wheel2, wheel3, wheel4)))
                    i2c0.writeto_mem(0x38, 0x00, b"".join([wheel1, wheel2, wheel3, wheel4]))
                    latest = x, y
                elif "claw" in data:
                    value = 8 if data["claw"] else 87
                    i2c0.writeto_mem(0x38, 0x10, value.to_bytes(1, 'big'))


    # Start event loop and create server task
    loop = asyncio.get_event_loop()
    loop.create_task(app.serve())
    loop.run_forever()

.. revealjs-notes::

   En este √∫ltimo ejemplo no me voy a extender mucho. Inicializamos un access point, y un servidor web con soporte para
   websockets, el cual permite conectarnos al coche y controlarlo desde el navegador.



Demo **coche**
--------------

.. revealjs-section::
   :data-background-color: #DDDDDD

.. raw:: html

    <iframe src="http://192.168.4.1/" height="600px" width="100%" style="border: 0;"></iframe>


.. revealjs-notes::

   ¬°Ahora, vamos a ver el coche en acci√≥n!



¬°Pru√©balo t√∫ mismo!
-------------------

.. revealjs-section::
   :data-background-color: #DDDDDD

* **SSID:** roverc.pro
* **Password:** roverc.pro
* **Url:** http://192.168.4.1


.. revealjs-notes::

   Y por si os sabe a poco, ¬°os invito a probarlo vosotros mismos! Conectad vuestro m√≥vil al wifi del coche, y acceded a
   la direcci√≥n indicada.


¬°Muchas gracias a todos!
========================

.. revealjs-section::
    :data-background-gradient: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);

.. revealjs-notes::

    Y mientras os dejo jugando con el coche... ¬°Hasta aqu√≠ la presentaci√≥n! Espero que hay√°is disfrutado y aprendido
    algo nuevo. S√© que he ido muy r√°pido, pero si ten√©is dudas, estoy disponible para resolverlas.



Recursos
========

.. revealjs-section::
    :data-background-color: #333333
    :data-transition-speed: default
    :data-transition: fade

.. revealjs-fragments::

    * üåê **Web oficial**: https://micropython.org
    * üìù **Editor online**: https://viper-ide.org
    * ü•Ω **Simulador online**: https://wokwi.com

.. revealjs-notes::

   Os dejo aqu√≠ disponibles estos recursos, para empezar a trabajar con Micropython.



QR
==

.. revealjs-section::
    :data-background-color: #4973ff
    :data-transition-speed: slow
    :data-transition: fade

.. image:: images/qr.svg
    :width: 60%

.. revealjs-notes::

   Y por supuesto, tambi√©n ten√©is esta misma presentaci√≥n, con los ejemplos de c√≥digo y los diagramas.



Python **M√°laga**
=================

.. revealjs-section::
    :data-background-color: #4973ff
    :data-transition-speed: slow
    :data-transition: fade

* üåê **Sitio web:** `python-malaga.es <https://www.python-malaga.es/>`_.
* ü§ù **Meetup:** `meetup.com/Python-Malaga <https://www.meetup.com/Python-Malaga/>`_.
* üê¶ **Twitter:** `@python_malaga <https://twitter.com/python_malaga>`_.
* ‚Äçüíº **LinkedIn:** `linkedin.com/groups/13110576 <https://www.linkedin.com/groups/13110576/>`_.
* üì± **Telegram:** `python_malaga <https://t.me/python_malaga>`_.

.. revealjs-notes::

   Y para m√°s presentaciones, apuntaros a la comunidad de Python M√°laga, donde hacemos m√°s charlas como esta. No
   olvid√©is seguirnos en nuestras redes sociales, y en nuestro grupo de Telegram.



**Contactar**
-------------

.. revealjs-section::
    :data-background-color: #333333
    :data-transition-speed: default
    :data-transition: fade

* üåê **Sitio web:** `nekmo.com <https://nekmo.com>`_
* üì´ **Email:** `contacto@nekmo.com <mailto:contacto@nekmo.com>`_
* üê¶ **Twitter:** `@nekmocom <https://twitter.com/nekmocom>`_
* üì± **Telegram:** `@nekmo <https://t.me/nekmo>`_
* üí° **Jabber:** `nekmo@nekmo.org <xmpp://nekmo@nekmo.org>`_

.. revealjs-notes::

   A cualquier cosa, ten√©is mi contacto disponible.
